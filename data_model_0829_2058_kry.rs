use rocket::serde::json::Json;
use serde::{Deserialize, Serialize};
use std::fmt;

/// Represents a generic error that can occur within the application.
#[derive(Debug, Serialize, Deserialize)]
pub enum AppError {
    InvalidInput(String),
    DatabaseError(String),
    // Add other error variants as needed
}

impl fmt::Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            AppError::InvalidInput(msg) => write!(f, "Invalid input: {}", msg),
            AppError::DatabaseError(msg) => write!(f, "Database error: {}", msg),
        }
    }
}

/// Represents a user in the system.
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct User {
    pub id: u32,
    pub name: String,
    pub email: String,
}

/// Represents a response from the API that includes a user and a success message.
#[derive(Debug, Serialize, Deserialize)]
pub struct ApiResponse<T> {
    pub success: bool,
    pub data: T,
    pub message: String,
}

/// Function to create a new user. It returns a result with either the created user or an error.
pub fn create_user(name: &str, email: &str) -> Result<User, AppError> {
    if name.is_empty() || email.is_empty() {
        Err(AppError::InvalidInput("Name and email are required.".to_string()))
    } else {
        Ok(User {
            id: 0, // In a real scenario, this would be generated by the database
            name: name.to_string(),
            email: email.to_string(),
        })
    }
}

/// Function to validate the email format.
pub fn validate_email(email: &str) -> Result<(), AppError> {
    if email.contains('@') && email.contains('.') {
        Ok(())
    } else {
        Err(AppError::InvalidInput("Email must contain '@' and '.' characters.".to_string()))
    }
}
